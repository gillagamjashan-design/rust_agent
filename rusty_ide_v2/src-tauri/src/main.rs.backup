// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

use anyhow::{Context, Result};
use chrono::{DateTime, Utc};
use notify::{Event, RecursiveMode, Watcher};
use parking_lot::Mutex;
use portable_pty::{native_pty_system, CommandBuilder, PtySize};
use rusty_ide::{AgentBridge, AgentContext, AgentResponse};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs;
use std::io::{Read, Write};
use std::path::{Path, PathBuf};
use std::sync::Arc;
use std::time::Duration;
use tauri::{Manager, State, Window};
use uuid::Uuid;

// ============================================================================
// Data Structures
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileInfo {
    pub name: String,
    pub path: String,
    pub is_dir: bool,
    pub size: u64,
    pub modified: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemContext {
    pub current_file: Option<String>,
    pub open_files: Vec<String>,
    pub working_directory: String,
    pub task_description: String,
    pub ide_source_code: Option<String>,
    pub terminal_output: Option<String>,
}

struct TerminalInstance {
    #[allow(dead_code)]
    master: Box<dyn portable_pty::MasterPty + Send>,
    writer: Box<dyn Write + Send>,
    reader: Arc<Mutex<Box<dyn Read + Send>>>,
    window: Window,
    id: String,
}

// ============================================================================
// Application State
// ============================================================================

struct AppState {
    terminals: Arc<Mutex<HashMap<String, TerminalInstance>>>,
    permissions: Arc<Mutex<Vec<String>>>,
    watchers: Arc<Mutex<HashMap<String, Box<dyn Watcher + Send>>>>,
    agent_bridge: Arc<AgentBridge>,
}

impl AppState {
    fn new() -> Result<Self> {
        Ok(Self {
            terminals: Arc::new(Mutex::new(HashMap::new())),
            permissions: Arc::new(Mutex::new(Vec::new())),
            watchers: Arc::new(Mutex::new(HashMap::new())),
            agent_bridge: Arc::new(AgentBridge::new().map_err(|e| anyhow::anyhow!("{}", e))?),
        })
    }
}

// ============================================================================
// Helper Functions
// ============================================================================

fn get_rusty_dir() -> Result<PathBuf> {
    let home = home::home_dir().context("Failed to get home directory")?;
    let rusty_dir = home.join(".rusty");
    fs::create_dir_all(&rusty_dir)?;
    Ok(rusty_dir)
}

fn get_permissions_file() -> Result<PathBuf> {
    let rusty_dir = get_rusty_dir()?;
    Ok(rusty_dir.join("permissions.json"))
}

fn load_permissions() -> Result<Vec<String>> {
    let permissions_file = get_permissions_file()?;
    if permissions_file.exists() {
        let content = fs::read_to_string(&permissions_file)?;
        let permissions: Vec<String> = serde_json::from_str(&content)?;
        Ok(permissions)
    } else {
        Ok(Vec::new())
    }
}

fn save_permissions(permissions: &[String]) -> Result<()> {
    let permissions_file = get_permissions_file()?;
    let content = serde_json::to_string_pretty(permissions)?;
    fs::write(&permissions_file, content)?;
    Ok(())
}

// ============================================================================
// Terminal Commands
// ============================================================================

#[tauri::command]
async fn create_terminal(state: State<'_, AppState>, window: Window) -> Result<String, String> {
    let terminal_id = Uuid::new_v4().to_string();

    let pty_system = native_pty_system();

    // Create a new pty
    let pair = pty_system
        .openpty(PtySize {
            rows: 24,
            cols: 80,
            pixel_width: 0,
            pixel_height: 0,
        })
        .map_err(|e| format!("Failed to open pty: {}", e))?;

    // Determine the shell to use
    #[cfg(unix)]
    let shell = std::env::var("SHELL").unwrap_or_else(|_| "/bin/bash".to_string());

    #[cfg(windows)]
    let shell = "powershell.exe";

    let mut cmd = CommandBuilder::new(shell);
    cmd.cwd(std::env::current_dir().unwrap_or_else(|_| PathBuf::from("/")));

    // Spawn the shell
    let _child = pair
        .slave
        .spawn_command(cmd)
        .map_err(|e| format!("Failed to spawn shell: {}", e))?;

    // Get reader and writer
    let reader = pair
        .master
        .try_clone_reader()
        .map_err(|e| format!("Failed to clone reader: {}", e))?;
    let writer = pair
        .master
        .take_writer()
        .map_err(|e| format!("Failed to get writer: {}", e))?;

    let reader = Arc::new(Mutex::new(reader));
    let reader_clone = Arc::clone(&reader);
    let window_clone = window.clone();
    let terminal_id_clone = terminal_id.clone();

    // Spawn a task to read from the pty and send to frontend
    tokio::spawn(async move {
        let mut buffer = [0u8; 8192];
        loop {
            let n = {
                let mut reader = reader_clone.lock();
                match reader.read(&mut buffer) {
                    Ok(n) if n > 0 => n,
                    _ => break,
                }
            };

            if n > 0 {
                let data = String::from_utf8_lossy(&buffer[..n]).to_string();
                let _ = window_clone.emit(
                    "terminal-data",
                    serde_json::json!({
                        "id": terminal_id_clone,
                        "data": data
                    }),
                );
            }
        }
    });

    let instance = TerminalInstance {
        master: pair.master,
        writer,
        reader,
        window: window.clone(),
        id: terminal_id.clone(),
    };

    state.terminals.lock().insert(terminal_id.clone(), instance);

    Ok(terminal_id)
}

#[tauri::command]
async fn write_to_terminal(
    state: State<'_, AppState>,
    id: String,
    data: String,
) -> Result<(), String> {
    let mut terminals = state.terminals.lock();
    let terminal = terminals
        .get_mut(&id)
        .ok_or_else(|| format!("Terminal {} not found", id))?;

    terminal
        .writer
        .write_all(data.as_bytes())
        .map_err(|e| format!("Failed to write to terminal: {}", e))?;

    terminal
        .writer
        .flush()
        .map_err(|e| format!("Failed to flush terminal: {}", e))?;

    Ok(())
}

#[tauri::command]
async fn resize_terminal(
    state: State<'_, AppState>,
    id: String,
    cols: u16,
    rows: u16,
) -> Result<(), String> {
    let terminals = state.terminals.lock();
    let terminal = terminals
        .get(&id)
        .ok_or_else(|| format!("Terminal {} not found", id))?;

    terminal
        .master
        .resize(PtySize {
            rows,
            cols,
            pixel_width: 0,
            pixel_height: 0,
        })
        .map_err(|e| format!("Failed to resize terminal: {}", e))?;

    Ok(())
}

#[tauri::command]
async fn close_terminal(state: State<'_, AppState>, id: String) -> Result<(), String> {
    let mut terminals = state.terminals.lock();
    terminals.remove(&id);
    Ok(())
}

// ============================================================================
// File Operations
// ============================================================================

#[tauri::command]
async fn read_file(state: State<'_, AppState>, path: String) -> Result<String, String> {
    // Check permission
    let permissions = state.permissions.lock();
    let path_buf = PathBuf::from(&path);
    let canonical = path_buf
        .canonicalize()
        .map_err(|e| format!("Failed to canonicalize path: {}", e))?;

    let allowed = permissions.iter().any(|p| {
        let p_path = PathBuf::from(p);
        canonical.starts_with(p_path)
    });

    if !allowed && !permissions.is_empty() {
        return Err(format!(
            "Access denied: {} is not in allowed workspace paths",
            path
        ));
    }

    fs::read_to_string(&path).map_err(|e| format!("Failed to read file: {}", e))
}

#[tauri::command]
async fn write_file(
    state: State<'_, AppState>,
    path: String,
    content: String,
) -> Result<(), String> {
    // Check permission
    let permissions = state.permissions.lock();
    let path_buf = PathBuf::from(&path);

    // Create parent directory if it doesn't exist
    if let Some(parent) = path_buf.parent() {
        fs::create_dir_all(parent)
            .map_err(|e| format!("Failed to create parent directory: {}", e))?;
    }

    let canonical = if path_buf.exists() {
        path_buf
            .canonicalize()
            .map_err(|e| format!("Failed to canonicalize path: {}", e))?
    } else {
        path_buf.clone()
    };

    let allowed = permissions.iter().any(|p| {
        let p_path = PathBuf::from(p);
        canonical.starts_with(p_path)
    });

    if !allowed && !permissions.is_empty() {
        return Err(format!(
            "Access denied: {} is not in allowed workspace paths",
            path
        ));
    }

    fs::write(&path, content).map_err(|e| format!("Failed to write file: {}", e))
}

#[tauri::command]
async fn list_files(
    state: State<'_, AppState>,
    directory: String,
) -> Result<Vec<FileInfo>, String> {
    // Check permission
    let permissions = state.permissions.lock();
    let dir_path = PathBuf::from(&directory);
    let canonical = dir_path
        .canonicalize()
        .map_err(|e| format!("Failed to canonicalize path: {}", e))?;

    let allowed = permissions.iter().any(|p| {
        let p_path = PathBuf::from(p);
        canonical.starts_with(p_path)
    });

    if !allowed && !permissions.is_empty() {
        return Err(format!(
            "Access denied: {} is not in allowed workspace paths",
            directory
        ));
    }

    let entries = fs::read_dir(&directory).map_err(|e| format!("Failed to read directory: {}", e))?;

    let mut files = Vec::new();

    for entry in entries {
        let entry = entry.map_err(|e| format!("Failed to read entry: {}", e))?;
        let metadata = entry
            .metadata()
            .map_err(|e| format!("Failed to read metadata: {}", e))?;

        let modified = metadata.modified().ok().and_then(|time| {
            let datetime: DateTime<Utc> = time.into();
            Some(datetime.to_rfc3339())
        });

        files.push(FileInfo {
            name: entry.file_name().to_string_lossy().to_string(),
            path: entry.path().to_string_lossy().to_string(),
            is_dir: metadata.is_dir(),
            size: metadata.len(),
            modified,
        });
    }

    Ok(files)
}

#[tauri::command]
async fn watch_directory(
    state: State<'_, AppState>,
    path: String,
    window: Window,
) -> Result<(), String> {
    let path_buf = PathBuf::from(&path);

    let window_clone = window.clone();
    let mut watcher =
        notify::recommended_watcher(move |res: std::result::Result<Event, notify::Error>| {
            match res {
                Ok(event) => {
                    let _ = window_clone.emit(
                        "file-system-event",
                        serde_json::json!({
                            "kind": format!("{:?}", event.kind),
                            "paths": event.paths.iter().map(|p| p.to_string_lossy().to_string()).collect::<Vec<_>>(),
                        }),
                    );
                }
                Err(e) => {
                    eprintln!("Watch error: {:?}", e);
                }
            }
        })
        .map_err(|e| format!("Failed to create watcher: {}", e))?;

    watcher
        .watch(&path_buf, RecursiveMode::Recursive)
        .map_err(|e| format!("Failed to watch directory: {}", e))?;

    state
        .watchers
        .lock()
        .insert(path.clone(), Box::new(watcher));

    Ok(())
}

#[tauri::command]
async fn unwatch_directory(state: State<'_, AppState>, path: String) -> Result<(), String> {
    state.watchers.lock().remove(&path);
    Ok(())
}

// ============================================================================
// Agent Communication Commands (using existing AgentBridge)
// ============================================================================

#[tauri::command]
async fn query_agent(
    state: State<'_, AppState>,
    workspace: String,
    current_file: Option<String>,
    current_code: Option<String>,
    files: Vec<String>,
    query: String,
) -> Result<AgentResponse, String> {
    let bridge = &state.agent_bridge;

    // Get IDE source code for self-awareness
    let ide_source = bridge.get_ide_source().unwrap_or_default();

    // Build context
    let mut context = AgentContext::new(query)
        .with_workspace(workspace)
        .with_files(files)
        .with_ide_source(ide_source);

    if let (Some(file), Some(code)) = (current_file, current_code) {
        context = context.with_current_file(file, code);
    }

    // Send request
    bridge.send_request(context).map_err(|e| e.to_string())?;

    // Wait for response with 30 second timeout
    let response = bridge
        .wait_for_response(Duration::from_secs(30))
        .map_err(|e| e.to_string())?;

    Ok(response)
}

#[tauri::command]
async fn check_agent_response(
    state: State<'_, AppState>,
) -> Result<Option<AgentResponse>, String> {
    let bridge = &state.agent_bridge;
    bridge.check_response().map_err(|e| e.to_string())
}

#[tauri::command]
async fn clear_agent_files(state: State<'_, AppState>) -> Result<(), String> {
    let bridge = &state.agent_bridge;
    bridge.clear().map_err(|e| e.to_string())
}

#[derive(Serialize)]
struct AgentInfo {
    agent_dir: String,
    request_path: String,
    response_path: String,
}

#[tauri::command]
async fn get_agent_info(state: State<'_, AppState>) -> Result<AgentInfo, String> {
    let bridge = &state.agent_bridge;

    Ok(AgentInfo {
        agent_dir: bridge.agent_dir().to_string_lossy().to_string(),
        request_path: bridge.request_path().to_string_lossy().to_string(),
        response_path: bridge.response_path().to_string_lossy().to_string(),
    })
}

// ============================================================================
// Permission System
// ============================================================================

#[tauri::command]
async fn grant_workspace_access(state: State<'_, AppState>, path: String) -> Result<(), String> {
    let mut permissions = state.permissions.lock();

    let path_buf = PathBuf::from(&path);
    let canonical = path_buf
        .canonicalize()
        .map_err(|e| format!("Failed to canonicalize path: {}", e))?;

    let canonical_str = canonical.to_string_lossy().to_string();

    if !permissions.contains(&canonical_str) {
        permissions.push(canonical_str);
        save_permissions(&permissions).map_err(|e| format!("Failed to save permissions: {}", e))?;
    }

    Ok(())
}

#[tauri::command]
async fn check_permission(state: State<'_, AppState>, path: String) -> Result<bool, String> {
    let permissions = state.permissions.lock();

    if permissions.is_empty() {
        return Ok(true); // No restrictions if no permissions set
    }

    let path_buf = PathBuf::from(&path);
    let canonical = path_buf
        .canonicalize()
        .map_err(|e| format!("Failed to canonicalize path: {}", e))?;

    let allowed = permissions.iter().any(|p| {
        let p_path = PathBuf::from(p);
        canonical.starts_with(p_path)
    });

    Ok(allowed)
}

#[tauri::command]
async fn get_permissions(state: State<'_, AppState>) -> Result<Vec<String>, String> {
    let permissions = state.permissions.lock();
    Ok(permissions.clone())
}

#[tauri::command]
async fn revoke_workspace_access(state: State<'_, AppState>, path: String) -> Result<(), String> {
    let mut permissions = state.permissions.lock();

    let path_buf = PathBuf::from(&path);
    let canonical = path_buf
        .canonicalize()
        .map_err(|e| format!("Failed to canonicalize path: {}", e))?;

    let canonical_str = canonical.to_string_lossy().to_string();
    permissions.retain(|p| p != &canonical_str);

    save_permissions(&permissions).map_err(|e| format!("Failed to save permissions: {}", e))?;

    Ok(())
}

// ============================================================================
// Self-Awareness
// ============================================================================

#[tauri::command]
async fn get_ide_source_code(state: State<'_, AppState>) -> Result<String, String> {
    let bridge = &state.agent_bridge;
    bridge.get_ide_source().map_err(|e| e.to_string())
}

// ============================================================================
// Main Application
// ============================================================================

fn main() {
    let app_state = AppState::new().expect("Failed to initialize app state");

    // Load saved permissions
    if let Ok(permissions) = load_permissions() {
        *app_state.permissions.lock() = permissions;
    }

    tauri::Builder::default()
        .manage(app_state)
        .invoke_handler(tauri::generate_handler![
            // Terminal
            create_terminal,
            write_to_terminal,
            resize_terminal,
            close_terminal,
            // File operations
            read_file,
            write_file,
            list_files,
            watch_directory,
            unwatch_directory,
            // Agent communication
            query_agent,
            check_agent_response,
            clear_agent_files,
            get_agent_info,
            // Permissions
            grant_workspace_access,
            check_permission,
            get_permissions,
            revoke_workspace_access,
            // Self-awareness
            get_ide_source_code,
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
